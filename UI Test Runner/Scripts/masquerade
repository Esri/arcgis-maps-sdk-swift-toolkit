#!/usr/bin/env bash
# Copyright 2020 Esri.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   https:***REMOVED***www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Usage instructions
helpFunction()
{
  bold=$(tput bold)
  normal=$(tput sgr0)
  underline=$(tput smul)
  echo ""
  echo "Usage: ${bold***REMOVED***masquerade${normal***REMOVED*** [${bold***REMOVED***-i${normal***REMOVED*** ${underline***REMOVED***file${normal***REMOVED***] [${bold***REMOVED***-o${normal***REMOVED*** ${underline***REMOVED***file${normal***REMOVED***] [${bold***REMOVED***-s${normal***REMOVED*** ${underline***REMOVED***file${normal***REMOVED***]"
  echo -e ""
  echo -e "\t${bold***REMOVED***-i${normal***REMOVED***"
  echo -e "\t\tPath to input file."
  echo -e "\t\tThe program will parse the input file looking for bracket-enclosed keys, ex: {{ KEY ***REMOVED******REMOVED***"
  echo -e ""
  echo -e "\t${bold***REMOVED***-o${normal***REMOVED*** "
  echo -e "\t\tPath to output generated file."
  echo -e "\t\tPlease ensure the the user has write permissions."
  echo -e ""
  echo -e "\t${bold***REMOVED***-s${normal***REMOVED***"
  echo -e "\t\tPath to a file containing key/value secrets."
  echo -e "\t\tEvery line is treated as a different key following the format KEY=VALUE where"
  echo -e "\t\t${underline***REMOVED***KEY${normal***REMOVED*** alpha-numeric and underscore characters"
  echo -e "\t\t${underline***REMOVED***=${normal***REMOVED*** the equal character '=' is a delimiter"
  echo -e "\t\t${underline***REMOVED***VALUE${normal***REMOVED*** any character before newline"
  echo -e ""
  echo -e "\t${bold***REMOVED***-f${normal***REMOVED***"
  echo -e "\t\tForce overwrite existing file at output path."
  echo -e ""
  exit 1
***REMOVED***

# -o force write defaults to false
FORCE_WRITE='false'

# Command line options
while getopts "i:o:s:f" opt
do
  case "$opt" in
***REMOVED***i ) INPUT_FILE="$OPTARG" ;;
***REMOVED***o ) OUTPUT_FILE="$OPTARG" ;;
***REMOVED***s ) SECRETS="$OPTARG" ;;
***REMOVED***f ) FORCE_WRITE='true' ;;
***REMOVED***? ) helpFunction ;; # Print helpFunction in case parameter is non-existent
  esac
done

# Validate -i param:
# - input param is not missing
# - input file is file
if [ -z "${INPUT_FILE***REMOVED***" ]; then
  echo "error: -i input file param is missing."
  helpFunction
elif [ ! -f "${INPUT_FILE***REMOVED***" ]; then
  echo "error: ${INPUT_FILE***REMOVED*** input file not found."
  helpFunction
fi

# Validate -o param:
# - output param is not missing
# - output file exists and has specified a forced overwrite
if [ -z "${OUTPUT_FILE***REMOVED***" ]; then
  echo "error: -o output file param is missing."
  helpFunction
elif [ -f "${OUTPUT_FILE***REMOVED***" ] && [ "${FORCE_WRITE***REMOVED***" == 'false' ]; then
  echo "error: ${OUTPUT_FILE***REMOVED*** file exists at path."
  echo "error: supply the -f flag to overwrite the output file."
  exit 1
fi

# Validate -s param:
# - secrets param is not missing
# - secrets is file
# - secrets is valid format
if [ -z "${SECRETS***REMOVED***" ]; then
  echo "error: -s secrets file param is missing."
  helpFunction
elif [ ! -f "${SECRETS***REMOVED***" ]; then
  echo "error: ${SECRETS***REMOVED*** secrets file not found."
  helpFunction
else
  while read -r line
  do
***REMOVED***if [[ ! $line =~ ^[a-zA-Z0-9_]*=.+$ ]]; then
***REMOVED***  echo "error: ${line***REMOVED*** invalid secret"
***REMOVED***  exit 1
***REMOVED***fi
  done < <(grep -Ev '^#' "${SECRETS***REMOVED***")
fi

# Create temporary directory
TEMP_DIR=$(mktemp -d -t secrets)

# Check if tmp dir was created
if [ ! "${TEMP_DIR***REMOVED***" ] || [ ! -d "${TEMP_DIR***REMOVED***" ]; then
  # Fallback to /tmp
  TEMP_DIR="/tmp/masque"
fi

# Deletes the temp directory
function cleanup {
  rm -rf "${TEMP_DIR***REMOVED***"
***REMOVED***

# Register the cleanup function to be called on the EXIT signal
trap cleanup EXIT

## Create temporary file path
TEMP_FILE="${TEMP_DIR***REMOVED***/$(basename "${INPUT_FILE***REMOVED***")"

# Copy input file to temporary file
cp "${INPUT_FILE***REMOVED***" "${TEMP_FILE***REMOVED***"

# First pass: iterate replacing keys found in template with values found in secrets
while read -r line
do
  # Extract key/value pairs
	KEY=$(echo "${line***REMOVED***" | cut -d= -f1)
	VALUE=$(echo "${line***REMOVED***" | cut -d= -f2)
	# Use sed to replace keys with values
  # Note, accepts space surrounding key
	sed -i.bak -e "s/{{ *${KEY***REMOVED*** ****REMOVED******REMOVED***/${VALUE***REMOVED***/g" "${TEMP_FILE***REMOVED***"
done < <(grep -Ev '^#' "${SECRETS***REMOVED***")

# Second pass: clean-up missed variable brackets
while read -r line
do
	# Use sed to replace keys with values
	sed -i.bak -e "s/{{.****REMOVED******REMOVED******REMOVED***g" "${TEMP_FILE***REMOVED***"
done < <(grep -Ev '^#' "${TEMP_FILE***REMOVED***")

# Move finished working file to ouput
mv "${TEMP_FILE***REMOVED***" "${OUTPUT_FILE***REMOVED***"

# Confirm the move was successful
if [ ! -f "${OUTPUT_FILE***REMOVED***" ]; then
  echo "error: ${OUTPUT_FILE***REMOVED*** could not write to output file."
  exit 1
fi
