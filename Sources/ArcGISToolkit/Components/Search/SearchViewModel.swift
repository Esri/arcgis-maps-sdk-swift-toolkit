***REMOVED***
***REMOVED***
***REMOVED*** Licensed under the Apache License, Version 2.0 (the "License");
***REMOVED*** you may not use this file except in compliance with the License.
***REMOVED*** You may obtain a copy of the License at
***REMOVED***
***REMOVED***   https:***REMOVED***www.apache.org/licenses/LICENSE-2.0
***REMOVED***
***REMOVED*** Unless required by applicable law or agreed to in writing, software
***REMOVED*** distributed under the License is distributed on an "AS IS" BASIS,
***REMOVED*** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
***REMOVED*** See the License for the specific language governing permissions and
***REMOVED*** limitations under the License.

***REMOVED***
import Combine
***REMOVED***

***REMOVED***/ Defines how many results to return; one, many, or automatic based on circumstance.
public enum SearchResultMode: Sendable {
***REMOVED******REMOVED***/ Search should always result in at most one result.
***REMOVED***case single
***REMOVED******REMOVED***/ Search should always try to return multiple results.
***REMOVED***case multiple
***REMOVED******REMOVED***/ Search should make a choice based on context. E.g. 'coffee shop' should be multiple results,
***REMOVED******REMOVED***/ while '380 New York St. Redlands' should be one result.
***REMOVED***case automatic
***REMOVED***

***REMOVED***/ The outcome of a geocode operation (search or suggestion).
***REMOVED***/
***REMOVED***/ An empty results or suggestions array means there were no results.
***REMOVED***/
***REMOVED***/ The `failure` case contains the error (if any) generated by the last search or suggestion
***REMOVED***/ operation.
public enum SearchOutcome: Sendable {
***REMOVED***case results([SearchResult])
***REMOVED***case suggestions([SearchSuggestion])
***REMOVED***case failure(String)
***REMOVED***

***REMOVED***/ Performs searches and manages search state for a search, or optionally without a UI connection.
@MainActor final class SearchViewModel: ObservableObject {
***REMOVED******REMOVED***/ Creates a `SearchViewModel`.
***REMOVED******REMOVED***/ - Parameters:
***REMOVED******REMOVED***/   - sources: Collection of search sources to be used.
***REMOVED******REMOVED***/   - viewpoint: The `Viewpoint` used to pan/zoom to results. If `nil`, there will be
***REMOVED******REMOVED***/   no zooming to results.
***REMOVED******REMOVED***/   - geoViewProxy: The proxy to provide access to geo view operations.
***REMOVED***init(
***REMOVED******REMOVED***sources: [SearchSource] = [],
***REMOVED******REMOVED***viewpoint: Binding<Viewpoint?>? = nil,
***REMOVED******REMOVED***geoViewProxy: GeoViewProxy? = nil
***REMOVED***) {
***REMOVED******REMOVED***self.sources = sources
***REMOVED******REMOVED***self.viewpoint = viewpoint
***REMOVED******REMOVED***self.geoViewProxy = geoViewProxy
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ The active search source.  If `nil`, the first item in `sources` is used.
***REMOVED***private var activeSource: SearchSource? = nil
***REMOVED***
***REMOVED******REMOVED***/ Tracks the current user-entered query. This property drives both suggestions and searches.
***REMOVED***@Published var currentQuery = "" {
***REMOVED******REMOVED***willSet {
***REMOVED******REMOVED******REMOVED***isEligibleForRequery = false
***REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED***guard let searchOutcome = searchOutcome else { return ***REMOVED***
***REMOVED******REMOVED******REMOVED***switch searchOutcome {
***REMOVED******REMOVED******REMOVED***case .suggestions(_):
***REMOVED******REMOVED******REMOVED******REMOVED***if currentQuery.isEmpty {
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***self.searchOutcome = nil
***REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED***default:
***REMOVED******REMOVED******REMOVED******REMOVED***self.searchOutcome = nil
***REMOVED******REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ The extent at the time of the last search.
***REMOVED***private var lastSearchExtent: Envelope? = nil {
***REMOVED******REMOVED***didSet {
***REMOVED******REMOVED******REMOVED***isEligibleForRequery = false
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ The current map/scene view extent. Defaults to `nil`.
***REMOVED******REMOVED***/
***REMOVED******REMOVED***/ This should be updated as the user navigates the map/scene. It will be
***REMOVED******REMOVED***/ used to determine the value of `isEligibleForRequery` for the 'Repeat
***REMOVED******REMOVED***/ search here' behavior. If that behavior is not wanted, it should be left `nil`.
***REMOVED***var geoViewExtent: Envelope? = nil {
***REMOVED******REMOVED***willSet {
***REMOVED******REMOVED******REMOVED***guard isGeoViewNavigating,
***REMOVED******REMOVED******REMOVED******REMOVED***  !isEligibleForRequery,
***REMOVED******REMOVED******REMOVED******REMOVED***  !currentQuery.isEmpty,
***REMOVED******REMOVED******REMOVED******REMOVED***  let lastExtent = lastSearchExtent,
***REMOVED******REMOVED******REMOVED******REMOVED***  let newExtent = newValue
***REMOVED******REMOVED******REMOVED***else { return ***REMOVED***
***REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED***viewpoint?.wrappedValue = nil
***REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED******REMOVED*** Check extent difference.
***REMOVED******REMOVED******REMOVED***let widthDiff = abs(lastExtent.width - newExtent.width)
***REMOVED******REMOVED******REMOVED***let heightDiff = abs(lastExtent.height - newExtent.height)
***REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED***let widthThreshold = lastExtent.width * 0.25
***REMOVED******REMOVED******REMOVED***let heightThreshold = lastExtent.height * 0.25
***REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED***isEligibleForRequery = widthDiff > widthThreshold || heightDiff > heightThreshold
***REMOVED******REMOVED******REMOVED***guard !isEligibleForRequery else { return ***REMOVED***
***REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED******REMOVED*** Check center difference.
***REMOVED******REMOVED******REMOVED***let centerDiff = GeometryEngine.distance(
***REMOVED******REMOVED******REMOVED******REMOVED***from: lastExtent.center,
***REMOVED******REMOVED******REMOVED******REMOVED***to: newExtent.center
***REMOVED******REMOVED******REMOVED***)
***REMOVED******REMOVED******REMOVED***let currentExtentAvg = (lastExtent.width + lastExtent.height) / 2.0
***REMOVED******REMOVED******REMOVED***let threshold = currentExtentAvg * 0.25
***REMOVED******REMOVED******REMOVED***isEligibleForRequery = centerDiff > threshold
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ The proxy to provide access to geo view operations.
***REMOVED***private var geoViewProxy: GeoViewProxy?
***REMOVED***
***REMOVED******REMOVED***/ `true` when the geoView is navigating, `false` otherwise. Set by the external client.
***REMOVED***var isGeoViewNavigating = false
***REMOVED***
***REMOVED******REMOVED***/ The `Viewpoint` used to pan/zoom to results. If `nil`, there will be no zooming to results.
***REMOVED***var viewpoint: Binding<Viewpoint?>? = nil
***REMOVED***
***REMOVED******REMOVED***/ The `GraphicsOverlay` used to display results. If `nil`, no results will be displayed.
***REMOVED***var resultsOverlay: GraphicsOverlay? = nil
***REMOVED***
***REMOVED******REMOVED***/ If `true`, will set the viewpoint to the extent of the results, plus a little buffer, which will
***REMOVED******REMOVED***/ cause the geoView to zoom to the extent of the results. If `false`,
***REMOVED******REMOVED***/ no setting of the viewpoint will occur.
***REMOVED***private var shouldZoomToResults = true
***REMOVED***
***REMOVED******REMOVED***/ `true` if the extent has changed by a set amount after a `Search` or `AcceptSuggestion`
***REMOVED******REMOVED***/ call. This property is used by the view to enable 'Repeat search here' functionality. This property is
***REMOVED******REMOVED***/ observable, and the view should use it to hide and show the 'repeat search' button.
***REMOVED******REMOVED***/ Changes to this property are driven by changes to the `geoViewExtent` property. This value will be
***REMOVED******REMOVED***/ `true` if the extent center changes by more than 25% of the average of the extent's height and width
***REMOVED******REMOVED***/ at the time of the last search or if the extent width/height changes by the same amount.
***REMOVED***@Published private(set) var isEligibleForRequery = false
***REMOVED***
***REMOVED******REMOVED***/ The search area to be used for the current query. Results will be limited to those.
***REMOVED******REMOVED***/ within `QueryArea`. Defaults to `nil`.
***REMOVED***var queryArea: Geometry? = nil
***REMOVED***
***REMOVED******REMOVED***/ Defines the center for the search. For most use cases, this should be updated by the view
***REMOVED******REMOVED***/ every time the user navigates the map.
***REMOVED***var queryCenter: Point?
***REMOVED***
***REMOVED******REMOVED***/ Defines how many results to return. Defaults to ``SearchResultMode/automatic``.
***REMOVED******REMOVED***/ In automatic mode, an appropriate number of results is returned based on the type of suggestion
***REMOVED******REMOVED***/ chosen (driven by the suggestion's `isCollection` property).
***REMOVED***var resultMode: SearchResultMode = .automatic
***REMOVED***
***REMOVED******REMOVED***/ A search outcome that contains the search and suggestion results. A `nil` value means no
***REMOVED******REMOVED***/ query has been made.
***REMOVED***@Published private(set) var searchOutcome: SearchOutcome? {
***REMOVED******REMOVED***didSet {
***REMOVED******REMOVED******REMOVED***if case let .results(results) = searchOutcome {
***REMOVED******REMOVED******REMOVED******REMOVED***display(searchResults: results)
***REMOVED******REMOVED******REMOVED******REMOVED***selectedResult = results.count == 1 ? results.first : nil
***REMOVED******REMOVED*** else {
***REMOVED******REMOVED******REMOVED******REMOVED***display(searchResults: [])
***REMOVED******REMOVED******REMOVED******REMOVED***selectedResult = nil
***REMOVED******REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Tracks selection of results from the `results` collection. When there is only one result,
***REMOVED******REMOVED***/ that result is automatically assigned to this property. If there are multiple results, the view sets
***REMOVED******REMOVED***/ this property upon user selection. This property is observable. The view should observe this
***REMOVED******REMOVED***/ property and update the associated GeoView's viewpoint, if configured.
***REMOVED***@Published var selectedResult: SearchResult? {
***REMOVED******REMOVED***willSet {
***REMOVED******REMOVED******REMOVED***(selectedResult?.geoElement as? Graphic)?.isSelected = false
***REMOVED***
***REMOVED******REMOVED***didSet {
***REMOVED******REMOVED******REMOVED***(selectedResult?.geoElement as? Graphic)?.isSelected = true
***REMOVED******REMOVED******REMOVED***display(selectedResult: selectedResult)
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Collection of search sources to be used. This list is maintained over time and is not nullable.
***REMOVED******REMOVED***/ The view should observe this list for changes. Consumers should add and remove sources from
***REMOVED******REMOVED***/ this list as needed.
***REMOVED******REMOVED***/ NOTE: Only the first source is currently used; multiple sources are not yet supported.
***REMOVED***var sources: [SearchSource] = []
***REMOVED***
***REMOVED******REMOVED***/ The currently executing async task. `currentTask` will be cancelled
***REMOVED******REMOVED***/ prior to starting another async task.
***REMOVED***private var currentTask: Task<Void, Never>? {
***REMOVED******REMOVED***willSet {
***REMOVED******REMOVED******REMOVED***currentTask?.cancel()
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Starts a search. `selectedResult` and `results`, among other properties, are set
***REMOVED******REMOVED***/ asynchronously. Other query properties are read to define the parameters of the search.
***REMOVED***func commitSearch() {
***REMOVED******REMOVED***currentTask = Task { await self.doSearch() ***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Repeats the last search, limiting results to the extent specified in `geoViewExtent`.
***REMOVED***func repeatSearch() {
***REMOVED******REMOVED***currentTask = Task { await self.doRepeatSearch() ***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Updates suggestions list asynchronously.
***REMOVED***func updateSuggestions() {
***REMOVED******REMOVED***guard currentSuggestion == nil
***REMOVED******REMOVED***else {
***REMOVED******REMOVED******REMOVED******REMOVED*** Don't update suggestions if currently searching for one.
***REMOVED******REMOVED******REMOVED***return
***REMOVED***
***REMOVED******REMOVED***
***REMOVED******REMOVED***currentTask = Task { await self.doUpdateSuggestions() ***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ The suggestion currently selected by the user.
***REMOVED***@Published var currentSuggestion: SearchSuggestion? {
***REMOVED******REMOVED***didSet {
***REMOVED******REMOVED******REMOVED***if let currentSuggestion = currentSuggestion {
***REMOVED******REMOVED******REMOVED******REMOVED***acceptSuggestion(currentSuggestion)
***REMOVED******REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Commits a search from a specific suggestion. Results will be set asynchronously. Behavior is
***REMOVED******REMOVED***/ generally the same as `commitSearch`, except `searchSuggestion` is used instead of the
***REMOVED******REMOVED***/ `currentQuery` property.
***REMOVED******REMOVED***/ - Parameter searchSuggestion: The suggestion to use to commit the search.
***REMOVED***func acceptSuggestion(_ searchSuggestion: SearchSuggestion) {
***REMOVED******REMOVED***currentQuery = searchSuggestion.displayTitle
***REMOVED******REMOVED***currentTask = Task { await self.doAcceptSuggestion(searchSuggestion) ***REMOVED***
***REMOVED***
***REMOVED***

private extension SearchViewModel {
***REMOVED******REMOVED***/ Method to execute an async `repeatSearch` operation.
***REMOVED***func doRepeatSearch() async {
***REMOVED******REMOVED***guard !currentQuery.trimmingCharacters(in: .whitespaces).isEmpty,
***REMOVED******REMOVED******REMOVED***  let queryExtent = geoViewExtent,
***REMOVED******REMOVED******REMOVED***  let source = currentSource()
***REMOVED******REMOVED***else { return ***REMOVED***
***REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED*** We're repeating a search, don't zoom to results.
***REMOVED******REMOVED***shouldZoomToResults = false
***REMOVED******REMOVED***await search(with: {
***REMOVED******REMOVED******REMOVED***try await source.repeatSearch(
***REMOVED******REMOVED******REMOVED******REMOVED***currentQuery,
***REMOVED******REMOVED******REMOVED******REMOVED***searchExtent: queryExtent
***REMOVED******REMOVED******REMOVED***)
***REMOVED***)
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Method to execute an async `search` operation.
***REMOVED***func doSearch() async {
***REMOVED******REMOVED***guard !currentQuery.trimmingCharacters(in: .whitespaces).isEmpty,
***REMOVED******REMOVED******REMOVED***  let source = currentSource()
***REMOVED******REMOVED***else { return ***REMOVED***
***REMOVED******REMOVED***
***REMOVED******REMOVED***await search(with: {
***REMOVED******REMOVED******REMOVED***try await source.search(
***REMOVED******REMOVED******REMOVED******REMOVED***currentQuery,
***REMOVED******REMOVED******REMOVED******REMOVED***searchArea: queryArea,
***REMOVED******REMOVED******REMOVED******REMOVED***preferredSearchLocation: queryCenter
***REMOVED******REMOVED******REMOVED***)
***REMOVED*** )
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Method to execute an async `suggest` operation.
***REMOVED***func doUpdateSuggestions() async {
***REMOVED******REMOVED***guard !currentQuery.trimmingCharacters(in: .whitespaces).isEmpty,
***REMOVED******REMOVED******REMOVED***  let source = currentSource()
***REMOVED******REMOVED***else { return ***REMOVED***
***REMOVED******REMOVED***
***REMOVED******REMOVED***do {
***REMOVED******REMOVED******REMOVED***let suggestions = try await source.suggest(
***REMOVED******REMOVED******REMOVED******REMOVED***currentQuery,
***REMOVED******REMOVED******REMOVED******REMOVED***searchArea: queryArea,
***REMOVED******REMOVED******REMOVED******REMOVED***preferredSearchLocation: queryCenter
***REMOVED******REMOVED******REMOVED***)
***REMOVED******REMOVED******REMOVED***searchOutcome = .suggestions(suggestions)
***REMOVED*** catch is CancellationError {
***REMOVED******REMOVED******REMOVED******REMOVED*** Do nothing if user cancelled and let next task set searchOutcome.
***REMOVED*** catch {
***REMOVED******REMOVED******REMOVED***searchOutcome = .failure(error.localizedDescription)
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Method to execute an async `search` operation using a search suggestion..
***REMOVED******REMOVED***/ - Parameter searchSuggestion: The suggestion to search for.
***REMOVED***func doAcceptSuggestion(_ searchSuggestion: SearchSuggestion) async {
***REMOVED******REMOVED***await search(
***REMOVED******REMOVED******REMOVED***with: {
***REMOVED******REMOVED******REMOVED******REMOVED***try await searchSuggestion.owningSource.search(
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***searchSuggestion,
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***searchArea: queryArea,
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***preferredSearchLocation: queryCenter
***REMOVED******REMOVED******REMOVED******REMOVED***)
***REMOVED******REMOVED***,
***REMOVED******REMOVED******REMOVED***isCollection: searchSuggestion.isCollection
***REMOVED******REMOVED***)
***REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED*** once we are done searching for the suggestion, then reset it to nil
***REMOVED******REMOVED***currentSuggestion = nil
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Method to execute a search action and process the results.
***REMOVED******REMOVED***/ - Parameter action: The action to perform prior to processing results.
***REMOVED******REMOVED***/ - Parameter isCollection: `true` if the results are based on a collection search.
***REMOVED***func search(
***REMOVED******REMOVED***with action: () async throws -> [SearchResult],
***REMOVED******REMOVED***isCollection: Bool = true) async {
***REMOVED******REMOVED******REMOVED***do {
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** User is performing a search, so set `lastSearchExtent`.
***REMOVED******REMOVED******REMOVED******REMOVED***lastSearchExtent = geoViewExtent
***REMOVED******REMOVED******REMOVED******REMOVED***try await process(searchResults: action(), isCollection: isCollection)
***REMOVED******REMOVED*** catch is CancellationError {
***REMOVED******REMOVED******REMOVED******REMOVED***searchOutcome = nil
***REMOVED******REMOVED*** catch {
***REMOVED******REMOVED******REMOVED******REMOVED***searchOutcome = .failure(error.localizedDescription)
***REMOVED******REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Method to process search results based on the current `resultMode`.
***REMOVED******REMOVED***/ - Parameters:
***REMOVED******REMOVED***/   - searchResults: The array of search results to process.
***REMOVED******REMOVED***/   - isCollection: `true` if the results are based on a collection search.
***REMOVED***func process(searchResults: [SearchResult], isCollection: Bool) {
***REMOVED******REMOVED***let effectiveResults: [SearchResult]
***REMOVED******REMOVED***
***REMOVED******REMOVED***switch resultMode {
***REMOVED******REMOVED***case .single:
***REMOVED******REMOVED******REMOVED***effectiveResults = Array(searchResults.prefix(1))
***REMOVED******REMOVED***case .multiple:
***REMOVED******REMOVED******REMOVED***effectiveResults = searchResults
***REMOVED******REMOVED***case .automatic:
***REMOVED******REMOVED******REMOVED***if isCollection {
***REMOVED******REMOVED******REMOVED******REMOVED***effectiveResults = searchResults
***REMOVED******REMOVED*** else {
***REMOVED******REMOVED******REMOVED******REMOVED***effectiveResults = Array(searchResults.prefix(1))
***REMOVED******REMOVED***
***REMOVED***
***REMOVED******REMOVED***
***REMOVED******REMOVED***searchOutcome = .results(effectiveResults)
***REMOVED***
***REMOVED***

extension SearchViewModel {
***REMOVED******REMOVED***/ Returns the search source to be used in geocode operations.
***REMOVED******REMOVED***/ - Returns: The search source to use.
***REMOVED***func currentSource() -> SearchSource? {
***REMOVED******REMOVED***let source: SearchSource?
***REMOVED******REMOVED***if let activeSource = activeSource {
***REMOVED******REMOVED******REMOVED***source = activeSource
***REMOVED*** else {
***REMOVED******REMOVED******REMOVED***source = sources.first
***REMOVED***
***REMOVED******REMOVED***return source
***REMOVED***
***REMOVED***

private extension SearchViewModel {
***REMOVED***func display(searchResults: [SearchResult]) {
***REMOVED******REMOVED***guard let resultsOverlay = resultsOverlay else { return ***REMOVED***
***REMOVED******REMOVED***let resultGraphics: [Graphic] = searchResults.compactMap { result in
***REMOVED******REMOVED******REMOVED***guard let graphic = result.geoElement as? Graphic else { return nil ***REMOVED***
***REMOVED******REMOVED******REMOVED***graphic.update(with: result)
***REMOVED******REMOVED******REMOVED***return graphic
***REMOVED***
***REMOVED******REMOVED***resultsOverlay.removeAllGraphics()
***REMOVED******REMOVED***resultsOverlay.addGraphics(resultGraphics)
***REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED*** Make sure we have a viewpoint to zoom to.
***REMOVED******REMOVED***guard let viewpoint = viewpoint else { return ***REMOVED***
***REMOVED******REMOVED***
***REMOVED******REMOVED***if !resultGraphics.isEmpty,
***REMOVED******REMOVED***   let envelope = resultsOverlay.extent,
***REMOVED******REMOVED***   shouldZoomToResults {
***REMOVED******REMOVED******REMOVED***let builder = EnvelopeBuilder(envelope: envelope)
***REMOVED******REMOVED******REMOVED***builder.expand(by: 1.1)
***REMOVED******REMOVED******REMOVED***let targetExtent = builder.toGeometry()
***REMOVED******REMOVED******REMOVED***display(newViewpoint: Viewpoint(boundingGeometry: targetExtent))
***REMOVED******REMOVED******REMOVED***lastSearchExtent = targetExtent
***REMOVED*** else {
***REMOVED******REMOVED******REMOVED***viewpoint.wrappedValue = nil
***REMOVED***
***REMOVED******REMOVED***
***REMOVED******REMOVED***if !shouldZoomToResults { shouldZoomToResults = true ***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***func display(selectedResult: SearchResult?) {
***REMOVED******REMOVED***guard let selectedResult = selectedResult else { return ***REMOVED***
***REMOVED******REMOVED***display(newViewpoint: selectedResult.selectionViewpoint)
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Update the viewpoint to the new viewpoint, if a geo view proxy was supplied, the transition
***REMOVED******REMOVED***/ will be animated.
***REMOVED***func display(newViewpoint: Viewpoint?) {
***REMOVED******REMOVED***if let geoViewProxy, let newViewpoint {
***REMOVED******REMOVED******REMOVED***Task { await geoViewProxy.setViewpoint(newViewpoint, duration: nil) ***REMOVED***
***REMOVED*** else {
***REMOVED******REMOVED******REMOVED***viewpoint?.wrappedValue = newViewpoint
***REMOVED***
***REMOVED***
***REMOVED***

extension SearchOutcome: Equatable {***REMOVED***

private extension Graphic {
***REMOVED***func update(with result: SearchResult) {
***REMOVED******REMOVED***if symbol == nil {
***REMOVED******REMOVED******REMOVED***symbol = Symbol.searchResult()
***REMOVED***
***REMOVED******REMOVED***setAttributeValue(result.displayTitle, forKey: "displayTitle")
***REMOVED******REMOVED***setAttributeValue(result.displaySubtitle, forKey: "displaySubtitle")
***REMOVED***
***REMOVED***

private extension Symbol {
***REMOVED******REMOVED***/ A search result marker symbol.
***REMOVED***static func searchResult() -> MarkerSymbol {
***REMOVED******REMOVED***let image = UIImage.mapPin
***REMOVED******REMOVED***let symbol = PictureMarkerSymbol(image: image)
***REMOVED******REMOVED***symbol.offsetY = image.size.height / 2.0
***REMOVED******REMOVED***return symbol
***REMOVED***
***REMOVED***

extension UIImage {
***REMOVED***static var mapPin: UIImage? {
***REMOVED******REMOVED***UIImage(named: "MapPin", in: .toolkitModule, with: nil)
***REMOVED***
***REMOVED***
