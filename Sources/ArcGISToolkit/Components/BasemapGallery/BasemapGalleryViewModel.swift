***REMOVED***
***REMOVED***
***REMOVED*** Licensed under the Apache License, Version 2.0 (the "License");
***REMOVED*** you may not use this file except in compliance with the License.
***REMOVED*** You may obtain a copy of the License at
***REMOVED***
***REMOVED***   https:***REMOVED***www.apache.org/licenses/LICENSE-2.0
***REMOVED***
***REMOVED*** Unless required by applicable law or agreed to in writing, software
***REMOVED*** distributed under the License is distributed on an "AS IS" BASIS,
***REMOVED*** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
***REMOVED*** See the License for the specific language governing permissions and
***REMOVED*** limitations under the License.

***REMOVED***
import Combine

***REMOVED***/ Manages the state for a `BasemapGallery`.
@MainActor class BasemapGalleryViewModel: ObservableObject {
***REMOVED******REMOVED***/ Creates a `BasemapGalleryViewModel`. Uses the given array of basemap gallery items.
***REMOVED******REMOVED***/ - Remark: If `items` is empty, ArcGIS Online's developer basemaps will
***REMOVED******REMOVED***/ be loaded and added to `items`.
***REMOVED******REMOVED***/ - Parameters:
***REMOVED******REMOVED***/   - geoModel: A geo model.
***REMOVED******REMOVED***/   - items: A list of pre-defined base maps to display.
***REMOVED***init(
***REMOVED******REMOVED***geoModel: GeoModel? = nil,
***REMOVED******REMOVED***items: [BasemapGalleryItem] = []
***REMOVED***) {
***REMOVED******REMOVED***self.items = items
***REMOVED******REMOVED***self.geoModel = geoModel
***REMOVED******REMOVED***geoModelDidChange(nil)
***REMOVED******REMOVED***
***REMOVED******REMOVED***if items.isEmpty {
***REMOVED******REMOVED******REMOVED******REMOVED*** We have no basemap items, so fetch the
***REMOVED******REMOVED******REMOVED******REMOVED*** developer basemaps from AGOL. Developer
***REMOVED******REMOVED******REMOVED******REMOVED*** basemaps are used because they're
***REMOVED******REMOVED******REMOVED******REMOVED*** API-key metered.
***REMOVED******REMOVED******REMOVED***fetchBasemaps(
***REMOVED******REMOVED******REMOVED******REMOVED***from: Portal.arcGISOnline(connection: .anonymous),
***REMOVED******REMOVED******REMOVED******REMOVED***useDeveloperBasemaps: true
***REMOVED******REMOVED******REMOVED***)
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Creates an instance using the given portal to retrieve basemaps.
***REMOVED******REMOVED***/ - Parameters:
***REMOVED******REMOVED***/   - geoModel: A geo model.
***REMOVED******REMOVED***/   - portal: The portal to use to load basemaps.
***REMOVED***init(
***REMOVED******REMOVED***_ geoModel: GeoModel? = nil,
***REMOVED******REMOVED***portal: Portal
***REMOVED***) {
***REMOVED******REMOVED***items = []
***REMOVED******REMOVED***self.geoModel = geoModel
***REMOVED******REMOVED***geoModelDidChange(nil)
***REMOVED******REMOVED***
***REMOVED******REMOVED***self.portal = portal
***REMOVED******REMOVED***portalDidChange(portal)
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ The error generated by fetching the `Basemaps` from the `Portal`.
***REMOVED***@Published var fetchBasemapsError: Error? = nil
***REMOVED***
***REMOVED******REMOVED***/ The error signifying the spatial reference of ``geoModel`` and the spatial reference of
***REMOVED******REMOVED***/ ``currentItem`` do not match.
***REMOVED***@Published private(set) var spatialReferenceMismatchError: SpatialReferenceMismatchError? = nil
***REMOVED***
***REMOVED******REMOVED***/ If the `GeoModel` is not loaded when passed to the `BasemapGalleryViewModel`, then
***REMOVED******REMOVED***/ the geoModel will be immediately loaded. The spatial reference of geoModel dictates which
***REMOVED******REMOVED***/ basemaps from the gallery are enabled. When an enabled basemap is selected by the user,
***REMOVED******REMOVED***/ the geoModel will have its basemap replaced with the selected basemap.
***REMOVED***var geoModel: GeoModel? {
***REMOVED******REMOVED***didSet {
***REMOVED******REMOVED******REMOVED***geoModelDidChange(oldValue)
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ The `Portal` object, if any. Setting the portal will automatically fetch it's basemaps
***REMOVED******REMOVED***/ and replace the ``items`` array with the fetched basemaps.
***REMOVED***var portal: Portal? {
***REMOVED******REMOVED***didSet {
***REMOVED******REMOVED******REMOVED***portalDidChange(oldValue)
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ The list of basemaps shown in the gallery.
***REMOVED***@Published var items: [BasemapGalleryItem]
***REMOVED***
***REMOVED******REMOVED***/ The `BasemapGalleryItem` representing the `GeoModel`'s current basemap. This may be a
***REMOVED******REMOVED***/ basemap which does not exist in the gallery.
***REMOVED***@Published private(set) var currentItem: BasemapGalleryItem? = nil {
***REMOVED******REMOVED***didSet {
***REMOVED******REMOVED******REMOVED***guard let item = currentItem else { return ***REMOVED***
***REMOVED******REMOVED******REMOVED******REMOVED*** If the portal is nil, the user passed in their own array
***REMOVED******REMOVED******REMOVED******REMOVED*** of basemaps, so clone the selected one prior to setting. This
***REMOVED******REMOVED******REMOVED******REMOVED*** prevents the "Object already owned" error.
***REMOVED******REMOVED******REMOVED******REMOVED*** If portal is non-nil, there's no need to clone the basemap
***REMOVED******REMOVED******REMOVED******REMOVED*** as the list of basemaps is reloaded from the portal each time.
***REMOVED******REMOVED******REMOVED***geoModel?.basemap = portal == nil ? item.basemap.clone() : item.basemap
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***private var fetchBasemapsTask: Task<Void, Never>?
***REMOVED***
***REMOVED******REMOVED***/ Handles changes to the `geoModel` property.
***REMOVED******REMOVED***/ - Parameter previousGeoModel: The previously set `GeoModel`.
***REMOVED***func geoModelDidChange(_ previousGeoModel: GeoModel?) {
***REMOVED******REMOVED***guard let geoModel = geoModel else { return ***REMOVED***
***REMOVED******REMOVED***if geoModel.loadStatus != .loaded {
***REMOVED******REMOVED******REMOVED***Task { await load(geoModel: geoModel) ***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Handles changes to the `portal` property.
***REMOVED******REMOVED***/ - Parameter previousPortal: The previously set `Portal`.
***REMOVED***func portalDidChange(_ previousPortal: Portal?) {
***REMOVED******REMOVED******REMOVED*** Remove all items from `items`.
***REMOVED******REMOVED***items.removeAll()
***REMOVED******REMOVED***
***REMOVED******REMOVED***guard let portal = portal else { return ***REMOVED***
***REMOVED******REMOVED***fetchBasemaps(from: portal)
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ This attempts to set ``currentItem``; it will be set only if its spatial reference
***REMOVED******REMOVED***/ matches with ``geoModel``'s spatial reference. Otherwise ``currentItem``
***REMOVED******REMOVED***/ will be unchanged.
***REMOVED******REMOVED***/ - Parameter basemapGalleryItem: The new, potential, basemap gallery item.
***REMOVED***@MainActor func setCurrentItem(
***REMOVED******REMOVED***_ basemapGalleryItem: BasemapGalleryItem
***REMOVED***) {
***REMOVED******REMOVED******REMOVED*** Reset the mismatch error.
***REMOVED******REMOVED***spatialReferenceMismatchError = nil
***REMOVED******REMOVED***
***REMOVED******REMOVED***if let geoModel = geoModel {
***REMOVED******REMOVED******REMOVED***Task {
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** Ensure the geoModel is loaded.
***REMOVED******REMOVED******REMOVED******REMOVED***try await geoModel.load()
***REMOVED******REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** Update the basemap gallery item's `spatialReferenceStatus`.
***REMOVED******REMOVED******REMOVED******REMOVED***try await basemapGalleryItem.updateSpatialReferenceStatus(
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***geoModel.actualSpatialReference
***REMOVED******REMOVED******REMOVED******REMOVED***)
***REMOVED******REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED******REMOVED***switch basemapGalleryItem.spatialReferenceStatus {
***REMOVED******REMOVED******REMOVED******REMOVED***case .match, .unknown:
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***currentItem = basemapGalleryItem
***REMOVED******REMOVED******REMOVED******REMOVED***case .noMatch:
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***spatialReferenceMismatchError = SpatialReferenceMismatchError(
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***basemapSpatialReference: basemapGalleryItem.spatialReference,
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***geoModelSpatialReference: geoModel.actualSpatialReference
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***)
***REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED***
***REMOVED*** else {
***REMOVED******REMOVED******REMOVED******REMOVED*** No geoModel so no SR checking possible; just set `currentItem`.
***REMOVED******REMOVED******REMOVED***currentItem = basemapGalleryItem
***REMOVED***
***REMOVED***
***REMOVED***

private extension BasemapGalleryViewModel {
***REMOVED******REMOVED***/ Fetches the basemaps from the given portal and appends `items` with
***REMOVED******REMOVED***/ items created from the fetched basemaps.
***REMOVED******REMOVED***/ - Parameters:
***REMOVED******REMOVED***/   - portal: Portal to fetch basemaps from
***REMOVED******REMOVED***/   - useDeveloperBasemaps: If `true`, will always use the portal's developer basemaps. If
***REMOVED******REMOVED***/   `false`, it will use either the portal's basemaps or vector basemaps, depending on the value of
***REMOVED******REMOVED***/   `portal.portalInfo.useVectorBasemaps`.
***REMOVED***func fetchBasemaps(
***REMOVED******REMOVED***from portal: Portal,
***REMOVED******REMOVED***useDeveloperBasemaps: Bool = false
***REMOVED***) {
***REMOVED******REMOVED***fetchBasemapsTask?.cancel()
***REMOVED******REMOVED***fetchBasemapsTask = Task {
***REMOVED******REMOVED******REMOVED***do {
***REMOVED******REMOVED******REMOVED******REMOVED***try await portal.load()
***REMOVED******REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED******REMOVED***let basemaps: [Basemap]
***REMOVED******REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED******REMOVED***if geoModel is Scene {
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***let basemaps3D = try await portal.basemaps3D
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***items.append(
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***contentsOf: basemaps3D.lazy.map { BasemapGalleryItem(basemap: $0) ***REMOVED***
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***)
***REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED******REMOVED***if useDeveloperBasemaps {
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***basemaps = try await portal.developerBasemaps
***REMOVED******REMOVED******REMOVED*** else if let portalInfo = portal.info,
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***  portalInfo.usesVectorBasemaps {
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***basemaps = try await portal.vectorBasemaps
***REMOVED******REMOVED******REMOVED*** else {
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***basemaps = try await portal.basemaps
***REMOVED******REMOVED******REMOVED***
***REMOVED******REMOVED******REMOVED******REMOVED***items += basemaps.map { BasemapGalleryItem(basemap: $0) ***REMOVED***
***REMOVED******REMOVED*** catch {
***REMOVED******REMOVED******REMOVED******REMOVED***fetchBasemapsError = error
***REMOVED******REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED******REMOVED***/ Loads the given `GeoModel` then sets `currentItem` to an item
***REMOVED******REMOVED***/ created with the geoModel's basemap.
***REMOVED******REMOVED***/ - Parameter geoModel: The `GeoModel` to load.
***REMOVED***func load(geoModel: GeoModel) async {
***REMOVED******REMOVED***try? await geoModel.load()
***REMOVED******REMOVED***if let basemap = geoModel.basemap {
***REMOVED******REMOVED******REMOVED***currentItem = BasemapGalleryItem(basemap: basemap)
***REMOVED*** else {
***REMOVED******REMOVED******REMOVED***currentItem = nil
***REMOVED***
***REMOVED***
***REMOVED***

***REMOVED***/ An error describing a spatial reference mismatch between a geo model and a basemap.
struct SpatialReferenceMismatchError: Error {
***REMOVED******REMOVED***/ The basemap's spatial reference.
***REMOVED***let basemapSpatialReference: SpatialReference?
***REMOVED***
***REMOVED******REMOVED***/ The geo model's spatial reference.
***REMOVED***let geoModelSpatialReference: SpatialReference?
***REMOVED***

extension SpatialReferenceMismatchError: Equatable {***REMOVED***

extension GeoModel {
***REMOVED******REMOVED***/ The actual spatial reference of the geo model.
***REMOVED******REMOVED***/ - Remark:
***REMOVED******REMOVED***/ - For `Map`, it is map's `spatialReference`.
***REMOVED******REMOVED***/ - For `Scene`, if the `sceneViewTilingScheme` is `webMercator`, then `actualSpatialReference`
***REMOVED******REMOVED***/ is `webMercator`. Otherwise scene's `spatialReference`.
***REMOVED***var actualSpatialReference: SpatialReference? {
***REMOVED******REMOVED***if let scene = self as? ArcGIS.Scene,
***REMOVED******REMOVED***   scene.tilingScheme == .webMercator {
***REMOVED******REMOVED******REMOVED***return .webMercator
***REMOVED*** else {
***REMOVED******REMOVED******REMOVED***return spatialReference
***REMOVED***
***REMOVED***
***REMOVED***
